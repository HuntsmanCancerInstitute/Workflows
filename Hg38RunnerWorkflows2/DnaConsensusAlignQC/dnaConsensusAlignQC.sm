# UMI Consensus DNA Alignment and QC Workflow geared to processing WGS, WES, and chIPSeq datasets with UMIs
# 28 Oct 2025
# David.Nix@hci.utah.edu
# Huntsman Cancer Institute

############ No need to modify anything in this document #############

# Params from config, see xxx.sing and xxx.yaml for details
nameBuild = str(config["name"]) + "_" + str(config["genomeBuild"])
useqFastqBarcodeTagger=config["useqFastqBarcodeTagger"]
useqConsensus=config["useqConsensus"]
mappingQuality=config["mappingQuality"]
baseQuality=config["baseQuality"]
passingReadDepth=config["passingReadDepth"]
fastqRead1 = config["fastqRead1"]
fastqRead2 = config["fastqRead2"]
uniObRCRegions = config["tnRunner"]+ config["uniObRCRegions"]
fastaIndex = config["tnRunner"]+ config["fastaIndex"]

# Threads and memory
allRam = int(round(float(config["allRam"])))
allThreads = int(config["allThreads"])
tenPerThreads = int(round(allThreads*0.1))
if tenPerThreads > 10:
    tenPerThreads = 10
else:
    tenPerThreads = 5
thirdThreads = int(round(allThreads/3,0))
twoThirdThreads = allThreads - thirdThreads
halfThreads = int(round(allThreads/2,0)) - 1
quarterThreads = int(round(allThreads/4,0)) - 1

# Apps not in path
bwa = "/BioApps/Bwa/bwa-mem2-2.3_x64-linux/bwa-mem2"
samtools = "/BioApps/Samtools/1.19/bin/samtools"
htslib = "/BioApps/Htslib/1.13/bin"
useq = "/BioApps/USeq/Apps"
java = "java -jar -Djava.io.tmpdir=. " + "-Xmx" + str(allRam) + "G"

############# Rules ##############

# Workflow trigger
rule Launcher:
    input:
        "QC/Json/"+ nameBuild+ "_AlignmentCount.json",
        "QC/ReadCoverage/"+ nameBuild+ "_UniObRC.json.gz"
    output:
        "COMPLETE"
    shell:
        "rm -rf Consensus MatchMates &> /dev/null; "
        "touch {output}"

############# Alignment ###############

# Alt and UMI aware align with bwa mem2 
rule Align:
    output:
        temp ("MatchMates/passingMM.sorted.bam")
    log:
        fb = "Logs/"+ nameBuild+ "_FastqBarcodeTagger.log",
        bw = "Logs/"+ nameBuild+ "_Bwa.log",
        mm = "Logs/"+ nameBuild+ "_MatchMates.log",
        mj = "QC/Json/"+ nameBuild+ "_MatchMates.json"
    params:
        rg ="\"@RG\\tID:"+nameBuild+"\\tPL:ILLUMINA\\tLB:"+nameBuild+"\\tSM:"+nameBuild+ "\\tCN:HCI\\tPU:"+nameBuild+"\""
    threads:
        allThreads
    priority: 100
    shell:
        r"""
        set -o pipefail; set -e
        {java} {useq}/FastqBarcodeTagger -f {fastqRead1} -s {fastqRead2} {useqFastqBarcodeTagger} 2> {log.fb} | \
        {bwa} mem -p -t {twoThirdThreads} -R {params} {fastaIndex} - 2> {log.bw} | \
        {java} {useq}/MatchMates -s MatchMates -j {log.mj} &> {log.mm}
        gunzip QC/Json/{nameBuild}_MatchMates.json.gz &>> {log.mm}
        """

# Call Consensus on the barcoded bam, set params appropriately in the yaml
rule Consensus:
    input:
        "MatchMates/passingMM.sorted.bam"
    output:
        temp ("Consensus/paired_1.fastq.gz"),
        temp ("Consensus/paired_2.fastq.gz"),
        temp ("Consensus/unpaired.fastq.gz"),
        temp ("Consensus/passing.sam.gz")
    threads:
        allThreads    
    log:
        "Logs/"+ nameBuild+ "_Consensus.log",
    priority: 100
    shell:
        "rm -rf Consensus &> /dev/null; "
        "{java} {useq}/Consensus {useqConsensus} -t {threads} -b {input} -s Consensus &> {log}"

# Align unpaired consensus fastq, might be no alignments
rule AlignUnpairedConsensusFastq:
    input:
        "Consensus/unpaired.fastq.gz"
    output:
        temp ("Alignment/unpaired.sam.gz")
    params:
        "\"@RG\\tID:"+nameBuild+"\\tPL:ILLUMINA\\tLB:"+nameBuild+"\\tSM:"+nameBuild+ "\\tCN:HCI\\tPU:"+nameBuild+"\""
    threads:
        halfThreads
    log:
        "Logs/"+ nameBuild+ "_AlignUnPairedConsensusFastq.log"
    priority: 100
    shell:
        r"""
        {{ set -o pipefail; set -e
        {bwa} mem -t {threads} -R {params} {fastaIndex} {input} | \
        {samtools} view -O SAM -q {mappingQuality} - | \
        gzip > {output} 
        }} 2> {log}
        """

# Align paired consensus fastq
rule AlignPairedConsensusFastq:
    input:
        "Consensus/paired_1.fastq.gz",
        "Consensus/paired_2.fastq.gz"
    output:
        temp ("Alignment/paired.sam.gz")
    params:
        rg ="\"@RG\\tID:"+nameBuild+"\\tPL:ILLUMINA\\tLB:"+nameBuild+"\\tSM:"+nameBuild+ "\\tCN:HCI\\tPU:"+nameBuild+"\""
    threads:
        halfThreads
    log:
        "Logs/"+ nameBuild+ "_AlignPairedConsensusFastq.log"
    priority: 100
    shell:
        r"""
        {{ set -o pipefail; set -e
        {bwa} mem -t {threads} -R {params} {fastaIndex} {input} | \
        {samtools} view -O SAM -q {mappingQuality} - | \
        gzip > {output}
        }} 2> {log}
        """

# Concatinate alignments
rule ConcatinateAlignments:
    input:
        "Consensus/passing.sam.gz",
        "Alignment/unpaired.sam.gz",
        "Alignment/paired.sam.gz"
    output:
        temp ("Alignment/concatinated.sam.gz")
    log:
        "Logs/"+ nameBuild+ "_ConcatinateAlignments.log"
    shell:
        "cat {input} 2> {log} > {output}"

# Fix mate info and sort, not always necessary but doesn't hurt
# Removes unaligned and secondary alignments (fixmate -r)
# Removes those with a MQ < minimum (view -q). 
rule SortFixMatesFilter:
    input:
        sam = "Alignment/concatinated.sam.gz",
        json = "QC/Json/" + nameBuild + "_FastqCount.json"
    output:
        a = "Alignment/"+ nameBuild+ ".cram",
        i = "Alignment/"+ nameBuild+ ".cram.crai"
    threads:
        allThreads
    log:
        "Logs/"+ nameBuild+ "_SortFixMatesFilter.log"
    shell:
        r"""
        {{ set -o pipefail; set -e
        rm -rf Tmp &> /dev/null
        mkdir -p Tmp
        {samtools} collate -O -u -@ {thirdThreads} -T Tmp/collateByName {input.sam} | \
        {samtools} fixmate -@ {tenPerThreads} -r -u - - | \
        {samtools} sort -u -@ {thirdThreads} -T Tmp/sortByCoor - | \
        {samtools} view -@ {tenPerThreads} --write-index --reference {fastaIndex} -q {mappingQuality} -o {output.a}##idx##{output.i} - 
        rm -rf Tmp &> /dev/null
        }} 2> {log}
        """

# For maximal error reduction run SAE:
# java -jar -Xmx10G ~/USeqApps/SamAlignmentExtractor -q 20 -a 0.65 -d -f -b OptiOriRef_Hg38.bam  
#    -r ~/TNRunner/Bed/Maughan/Maughan_10Flank_2_Covered_LargerRegions_Pad250bpHg38.bed.gz -s SAE


############################# QC ###############################

# Count the number of fastq records
rule CountFastq:
    input:
        fastqRead1
    output:
        "QC/Json/" + nameBuild + "_FastqCount.json"
    shell:
        "x=$(gunzip -c {input} | wc -l | tr -d \" \") && "
        "y=$(($x/2)) && "
        "echo \{{ > {output} && "
        "echo \\\"numberFastqReads\\\": $y >> {output} && "
        "echo \}} >> {output}"

# Count number of alignments, total, not pairs
rule CountFinalAlignments:
    input:
        "Alignment/"+ nameBuild+ ".cram"
    output:
        "QC/Json/"+ nameBuild+ "_AlignmentCount.json"
    log:
        "Logs/"+ nameBuild+ "_CountFinalAlignments.log"
    shell:
        "x=$({samtools} view {input} 2>> {log} | wc -l | tr -d \" \") && "
        "echo \{{ > {output} && "
        "echo \\\"numberAlignments\\\": $x >> {output} && "
        "echo \}} >> {output}"

# BamPileup file for Read Coverage, this can take a long time so skip it if you don't want read coverage stats
rule BamPileup:
    input:
        "Alignment/"+ nameBuild+ ".cram"
    output:
        bp = temp ("Alignment/"+ nameBuild+ ".bp.txt.gz"),
        index = temp ("Alignment/"+ nameBuild+ ".bp.txt.gz.tbi")
    log:
        "Logs/"+ nameBuild+ "_BamPileup.log"
    threads:
        halfThreads
    shell:
        "{java} {useq}/BamPileup -b {input} -r {uniObRCRegions} -f {fastaIndex} "
        "-s {output.bp} -p {threads} -t {htslib} -q {baseQuality} -m {mappingQuality} &> {log} "
        
# Calculate unique observation read coverage stats
rule UniObRC:
    input:
        gz = "Alignment/"+ nameBuild+ ".bp.txt.gz",
        ix = "Alignment/"+ nameBuild+ ".bp.txt.gz.tbi"
    output:
        "QC/ReadCoverage/"+ nameBuild+ "_UniObRC.json.gz"
    log:
        "Logs/"+ nameBuild+ "_UniObRC.log"
    threads:
        quarterThreads
    shell:
        "set -e; "
        "{java} {useq}/UniObRC -u {input.gz} -r {uniObRCRegions} -s QC/ReadCoverage/{nameBuild}_UniObRC.bed.gz "
        "-d {passingReadDepth} -c 10000 -p {threads}  &> {log}; "
        "rm -rf QC/ReadCoverage/{nameBuild}_UniObRC.bed &>> {log}; "

onerror:
    shell( "rm -f STARTED COMPLETE; touch FAILED")


